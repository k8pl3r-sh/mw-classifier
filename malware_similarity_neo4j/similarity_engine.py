#!/usr/bin/env python3

import os
from utils.neo4j_graph import *
from neo4j import GraphDatabase
from features.features_extractor import FeaturesExtractor
from utils.logger import Log
from utils.tools import pe_check, filename_from_path
from malware_similarity_neo4j.minhash import MinHash

import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt


class SimilarityEngine:
    def __init__(self, config: dict):
        self.log = Log("SimilarityEngine", config)
        self.config = config
        self.neo4j = Neo4jGraph(config)
        self.malware_paths = []  # where we'll store the malware file paths
        self.similarity_matrix = np.zeros((0, 0))
        self.malware_attributes = dict()  # where we'll store the malware's extracted features
        self.minhash = MinHash(num_hashes=128)

    def get_neo4j_driver(self):
        self.neo4j.check_up()  # Check if Neo4J is up and running
        uri = self.config['neo4j']['uri']
        auth = (self.config['neo4j']['user'], self.config['neo4j']['password'])
        return GraphDatabase.driver(uri, auth=auth)

    @staticmethod
    def close_neo4j_driver(driver):
        driver.close()

    def extract_features(self, target_directory: str, sampling: bool = False):

        i = 0
        extractor = FeaturesExtractor(self.config)
        for root, dirs, paths in os.walk(target_directory):
            for path in paths:
                fullpath = os.path.join(root, path)
                if pe_check(fullpath):  # if it is a PE
                    i += 1

                    if not sampling or i % 100 == 0:  # Echantillonage pour avoir un max de familles de malwares
                        filename = filename_from_path(fullpath)
                        # INFO : malware_path : filename can't start with a number for Neo4J
                        self.malware_paths.append(filename)  # TODO : check use because key of another dict
                        self.malware_attributes[filename] = extractor.extract_features(fullpath)


    def create_similarity_graph(self, target_directory, threshold: float = 0.8, save: bool = False):
        """
        Create a similarity graph for PE binaries in a target directory and export it to a Neo4j database.

        This function scans the target directory for PE binaries, extracts their features,
        builds a similarity graph based on the Jaccard index of extracted strings, and exports the graph to Neo4j.

        Args:
            target_directory (str): The directory to scan for PE binaries.
            threshold (float, optional): The Jaccard index threshold for creating edges in the graph. Default is 0.8.
            save (bool, optional): Whether to save the graph as a Cypher script. Default is False.

        Examples:
            # >>> config = {
            # ...     'neo4j': {
            # ...         'uri': 'bolt://localhost:7687',
            # ...         'user': 'neo4j',
            # ...         'password': 'password'
            # ...     }
            # ... }
            # >>> engine = SimilarityEngine(config)
            # >>> engine.create_similarity_graph('/path/to/pe/files', threshold=0.75, save=True)
            Graph exported to Neo4j database
            Neo4J instance is accessible at http://localhost:7474/browser/
        """
        self.neo4j.start_neo4j_container()

        self.extract_features(target_directory, sampling=False)
        self.log.debug(f"Malware paths found {self.malware_paths}")
        self.log.info(f"Found {len(self.malware_paths)} PE binaries in {target_directory}")
        # Connect to Neo4j
        driver = self.get_neo4j_driver()

        # Initialize an empty similarity matrix (N x N)
        self.similarity_matrix = np.zeros((len(self.malware_paths), len(self.malware_paths)))
        # Optional: set the diagonal to 1 (self-similarity)
        np.fill_diagonal(self.similarity_matrix, 1.0)

        with driver.session() as session:

            # Create nodes
            for path in self.malware_paths:
                properties = {
                    'family': path.split("_")[0],
                    'path': path,  # path is necessary for relationships creation
                    'color': self.neo4j.get_color_by_label(path.split("_")[0])
                }

                label = path.split("_")[0].replace("-", "_")  # '-' not allowed in nodes names on neo4j
                session.execute_write(self.neo4j.create_node, label, properties)

            # Create relationships based on the Jaccard index
            self.create_relationships(threshold, session)

        SimilarityEngine.close_neo4j_driver(driver)
        self.log.info("Graph exported to Neo4j database")

        if save:
            self.neo4j.save_graph_as_cypher(self.malware_paths, self.malware_attributes, threshold)
        self.log.info("Neo4J instance is accessible at http://localhost:7474/browser/")

    def search_similarities(self, malware1: str, malware2: str, threshold: float, session):

        # TODO : Need to be developped to be the function to edit for model settings, parameters and machine learning
        binary_vector_1 = self.malware_attributes[malware1]['StaticIat']
        binary_vector_2 = self.malware_attributes[malware2]['StaticIat']

        similarity_1 = self.minhash.compute_minhash_similarity(binary_vector_1, binary_vector_2)

        # Mean :
        binary_vector_1 = self.malware_attributes[malware1]['Strings']
        binary_vector_2 = self.malware_attributes[malware2]['Strings']
        # jaccard_index2 = jaccard_score(binary_vector_1, binary_vector_2)

        similarity_2 = self.minhash.compute_minhash_similarity(binary_vector_1, binary_vector_2)

        jaccard_index = (similarity_1 + similarity_2) / 2
        self.log.debug(f"Approximate global Jaccard: {jaccard_index}")
        # TODO : need an optimization here, too long for huge sets to compare malware in one to one
        if jaccard_index > threshold:
            session.execute_write(self.neo4j.create_relationship, malware1, malware2, jaccard_index)

        # Ensure you're indexing with integers, not strings
        index_1 = self.malware_paths.index(malware1)
        index_2 = self.malware_paths.index(malware2)
        # Fill the similarity matrix symmetrically
        self.similarity_matrix[index_1, index_2] = jaccard_index
        self.similarity_matrix[index_2, index_1] = jaccard_index

    def create_relationships(self, threshold: float, session):
        for malware1, malware2 in itertools.combinations(self.malware_paths, 2):
            self.search_similarities(malware1, malware2, threshold, session)

    def run(self, target_directory: str, threshold: float = 0.7, save: bool = False):
        self.create_similarity_graph(target_directory, threshold, save)

    def similarity_matrix_heatmap(self, filename: str):
        # Set up the matplotlib figure
        plt.figure(figsize=(25, 25), dpi=300)

        # Create a heatmap using seaborn
        ax = sns.heatmap(self.similarity_matrix,
                         xticklabels=self.malware_paths,
                         yticklabels=self.malware_paths,
                         cmap="YlGnBu",  # You can change the color map here
                         annot=False,  # Set to True to display the Jaccard index values
                         fmt=".2f")  # Format the numbers to 2 decimal places

        # Add labels and title
        ax.set_title("Malware Similarity Matrix (Jaccard Index)")
        plt.xlabel("Malware Samples")
        plt.ylabel("Malware Samples")
        plt.xticks(rotation=90, fontsize=8)
        plt.yticks(rotation=0, fontsize=8)

        # Display the heatmap
        plt.savefig(filename, format='png', bbox_inches='tight')
