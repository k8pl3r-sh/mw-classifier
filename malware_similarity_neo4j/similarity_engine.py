#!/usr/bin/env python3

import os
from utils.neo4j_graph import *
from neo4j import GraphDatabase
from features.features_extractor import FeaturesExtractor
from utils.logger import Log


class SimilarityEngine:
    def __init__(self, config: dict):
        self.log = Log("SimilarityEngine", config)
        self.config = config
        self.neo4j = Neo4jGraph(config)

    @staticmethod
    def pe_check(fullpath: str) -> bool:
        """
        Perform a cursory sanity check to verify that 'fullpath' is a Windows PE executable.

        Windows PE executables start with the two bytes 'MZ'.

        Args:
            fullpath (str): The full path to the file to check.

        Returns:
            bool: True if the file starts with 'MZ', indicating it is a PE executable, False otherwise.

        Examples:
            # >>> pe_check('path/to/valid_pe.exe')
            True
            # >>> pe_check('path/to/invalid_pe.txt')
            False
            >>> SimilarityEngine.pe_check('path/to/nonexistent_file.exe')
            Traceback (most recent call last):
                ...
            FileNotFoundError: [Errno 2] No such file or directory: 'path/to/nonexistent_file.exe'
        """
        try:
            with open(fullpath, 'rb') as file:
                return file.read(2) == b'MZ'
        except FileNotFoundError as e:
            raise e

    @staticmethod
    def filename_from_path(path: str) -> str:
        """
        Extract the filename from a given file path.

        Args:
            path (str): The full path to the file.

        Returns:
            str: The filename extracted from the given path.

        Examples:
            # >>> SimilarityEngine.filename_from_path('/home/user/file.txt')
            'file.txt'
            >>> SimilarityEngine.filename_from_path('../malware_similarity_neo4j/similarity_engine.py')
            'similarity_engine.py'
            >>> SimilarityEngine.filename_from_path('/')
            ''
        """
        return os.path.basename(path)

    def create_similarity_graph(self, target_directory: str, threshold: float = 0.8, save: bool = False):
        """
        Create a similarity graph for PE binaries in a target directory and export it to a Neo4j database.

        This function scans the target directory for PE binaries, extracts their features,
        builds a similarity graph based on the Jaccard index of extracted strings, and exports the graph to Neo4j.

        Args:
            target_directory (str): The directory to scan for PE binaries.
            threshold (float, optional): The Jaccard index threshold for creating edges in the graph. Default is 0.8.
            save (bool, optional): Whether to save the graph as a Cypher script. Default is False.

        Examples:
            # >>> config = {
            # ...     'neo4j': {
            # ...         'uri': 'bolt://localhost:7687',
            # ...         'user': 'neo4j',
            # ...         'password': 'password'
            # ...     }
            # ... }
            # >>> engine = SimilarityEngine(config)
            # >>> engine.create_similarity_graph('/path/to/pe/files', threshold=0.75, save=True)
            Graph exported to Neo4j database
            Neo4J instance is accessible at http://localhost:7474/browser/
        """
        uri = self.config['neo4j']['uri']
        auth = (self.config['neo4j']['user'], self.config['neo4j']['password'])
        self.neo4j.start_neo4j_container()

        # Do the main work : finding PE binaries in the target directory, extract features, and build the graph
        malware_paths = []  # where we'll store the malware file paths
        malware_attributes = dict()  # where we'll store the malware strings
        extractor = FeaturesExtractor(self.config)

        # TODO : check if path exist and if it is not empty
        for root, dirs, paths in os.walk(target_directory):
            for path in paths:
                fullpath = os.path.join(root, path)
                if SimilarityEngine.pe_check(fullpath):  # if it is a PE
                    filename = SimilarityEngine.filename_from_path(fullpath)
                    malware_paths.append(filename) # TODO : check use because key of another dict
                    malware_attributes[filename] = extractor.extract_features(fullpath)
                    """
                    Equivalent de l'ancien
                    {  # Voir pour faire de l'ajout en dynamique
                        'strings': get_strings(fullpath),
                        'iat': extract_iat(fullpath)
                    }
                    """

        # Connect to Neo4j
        driver = GraphDatabase.driver(uri, auth=auth)

        with driver.session() as session:
            # Create nodes
            for path in malware_paths:
                session.execute_write(self.neo4j.create_node, path)

            # Create relationships based on the Jaccard index
            for malware1, malware2 in itertools.combinations(malware_paths, 2):
                jaccard_index = jaccard(malware_attributes[malware1]['Strings'], malware_attributes[malware2]['Strings'])
                if jaccard_index > threshold:
                    session.execute_write(self.neo4j.create_relationship, malware1, malware2, jaccard_index)

        driver.close()
        self.log.info("Graph exported to Neo4j database")

        if save:
            self.neo4j.save_graph_as_cypher(malware_paths, malware_attributes, threshold)
        self.log.info("Neo4J instance is accessible at http://localhost:7474/browser/")

    def run(self, target_directory: str, threshold: float = 0.6, save: bool = False):
        self.create_similarity_graph(target_directory, threshold, save)
