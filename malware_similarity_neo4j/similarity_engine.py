#!/usr/bin/env python3

import os
from utils.neo4j_graph import *
from neo4j import GraphDatabase
from features.features_extractor import FeaturesExtractor
from utils.logger import Log

import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

from sklearn.metrics import jaccard_score  # Will be removed


class SimilarityEngine:
    def __init__(self, config: dict):
        self.log = Log("SimilarityEngine", config)
        self.config = config
        self.neo4j = Neo4jGraph(config)

    @staticmethod
    def pe_check(fullpath: str) -> bool: # TODO : remove from the object
        """
        Perform a cursory sanity check to verify that 'fullpath' is a Windows PE executable.
        Windows PE executables start with the two bytes 'MZ'.

        Args:
            fullpath (str): The full path to the file to check.

        Returns:
            bool: True if the file starts with 'MZ', indicating it is a PE executable, False otherwise.

        Examples:
            # >>> pe_check('path/to/valid_pe.exe')
            True
            # >>> pe_check('path/to/invalid_pe.txt')
            False
            >>> SimilarityEngine.pe_check('path/to/nonexistent_file.exe')
            Traceback (most recent call last):
                ...
            FileNotFoundError: [Errno 2] No such file or directory: 'path/to/nonexistent_file.exe'
        """
        try:
            with open(fullpath, 'rb') as file:
                return file.read(2) == b'MZ'
        except FileNotFoundError as e:
            raise e

    @staticmethod
    def filename_from_path(path: str) -> str: # TODO : remove from the object
        """
        Extract the filename from a given file path.

        Args:
            path (str): The full path to the file.

        Returns:
            str: The filename extracted from the given path.

        Examples:
            # >>> SimilarityEngine.filename_from_path('/home/user/file.txt')
            'file.txt'
            >>> SimilarityEngine.filename_from_path('../malware_similarity_neo4j/similarity_engine.py')
            'similarity_engine.py'
            >>> SimilarityEngine.filename_from_path('/')
            ''
        """
        return os.path.basename(path)

    def create_similarity_graph(self, target_directory: str, threshold: float = 0.8, save: bool = False):
        """
        Create a similarity graph for PE binaries in a target directory and export it to a Neo4j database.

        This function scans the target directory for PE binaries, extracts their features,
        builds a similarity graph based on the Jaccard index of extracted strings, and exports the graph to Neo4j.

        Args:
            target_directory (str): The directory to scan for PE binaries.
            threshold (float, optional): The Jaccard index threshold for creating edges in the graph. Default is 0.8.
            save (bool, optional): Whether to save the graph as a Cypher script. Default is False.

        Examples:
            # >>> config = {
            # ...     'neo4j': {
            # ...         'uri': 'bolt://localhost:7687',
            # ...         'user': 'neo4j',
            # ...         'password': 'password'
            # ...     }
            # ... }
            # >>> engine = SimilarityEngine(config)
            # >>> engine.create_similarity_graph('/path/to/pe/files', threshold=0.75, save=True)
            Graph exported to Neo4j database
            Neo4J instance is accessible at http://localhost:7474/browser/
        """
        uri = self.config['neo4j']['uri']
        auth = (self.config['neo4j']['user'], self.config['neo4j']['password'])
        self.neo4j.start_neo4j_container()

        # Do the main work : finding PE binaries in the target directory, extract features, and build the graph
        self.malware_paths = []  # where we'll store the malware file paths
        malware_attributes = dict()  # where we'll store the malware strings
        extractor = FeaturesExtractor(self.config)

        # TODO : check if path exist and if it is not empty
        for root, dirs, paths in os.walk(target_directory):
            for path in paths:
                fullpath = os.path.join(root, path)
                if SimilarityEngine.pe_check(fullpath):  # if it is a PE
                    filename = SimilarityEngine.filename_from_path(fullpath)
                    # INFO : malware_path : filename can't start with a number for Neo4J
                    self.malware_paths.append(filename)  # TODO : check use because key of another dict
                    malware_attributes[filename] = extractor.extract_features(fullpath)
                    """
                    Equivalent de l'ancien
                    {  # Voir pour faire de l'ajout en dynamique
                        'strings': get_strings(fullpath),
                        'iat': extract_iat(fullpath)
                    }
                    """
        self.log.debug(f"Malware paths found {self.malware_paths}")
        self.log.info(f"Found {len(self.malware_paths)} PE binaries in {target_directory}")
        # Connect to Neo4j
        driver = GraphDatabase.driver(uri, auth=auth)

        with driver.session() as session:
            # Create nodes
            for path in self.malware_paths:
                properties = {
                    'Family': path.split("_")[0],
                    'path': path  # path is necessary for relationships creation
                }
                # TODO : if file has no family name, manage the case

                label = path.split("_")[0].replace("-", "_")  # '-' not allowed in nodes names on neo4j
                session.execute_write(self.neo4j.create_node, label, properties)

            ### Similarity matrix ###
            # Number of malware samples
            num_malwares = len(self.malware_paths)
            # Initialize an empty similarity matrix (N x N)
            self.similarity_matrix = np.zeros((num_malwares, num_malwares))
            # Optional: set the diagonal to 1 (self-similarity)
            np.fill_diagonal(self.similarity_matrix, 1.0)

            # Create relationships based on the Jaccard index
            for malware1, malware2 in itertools.combinations(self.malware_paths, 2):
                # jaccard_index = jaccard_score(malware_attributes[malware1]['Strings'], malware_attributes[malware2]['Strings']) # replace jaccard_score by jaccard and remove s on the utils
                binary_vector_1 = malware_attributes[malware1]['Strings']
                binary_vector_2 = malware_attributes[malware2]['Strings']

                jaccard_index = jaccard_score(binary_vector_1, binary_vector_2)
                self.log.debug(f"Jaccard index between {malware1} and {malware2} : {jaccard_index}")
                # TODO : need an optimization here, too long for huge sets to compare malware in one to one
                if jaccard_index > threshold:
                    # TODO : Si les labels/familles sont différents, coloriser le lien pour être identifiable
                    session.execute_write(self.neo4j.create_relationship, malware1, malware2, jaccard_index)

                # Ensure you're indexing with integers, not strings
                index_1 = self.malware_paths.index(malware1)
                index_2 = self.malware_paths.index(malware2)
                # Fill the similarity matrix symmetrically
                self.similarity_matrix[index_1, index_2] = jaccard_index
                self.similarity_matrix[index_2, index_1] = jaccard_index

        driver.close()
        self.log.info("Graph exported to Neo4j database")

        if save:
            self.neo4j.save_graph_as_cypher(self.malware_paths, malware_attributes, threshold)
        self.log.info("Neo4J instance is accessible at http://localhost:7474/browser/")

    def create_relationships(self):
        ...


    def run(self, target_directory: str, threshold: float = 0.7, save: bool = False):
        self.create_similarity_graph(target_directory, threshold, save)

    def similarity_matrix_heatmap(self, filename: str):
        # Set up the matplotlib figure
        plt.figure(figsize=(25, 25), dpi=300)

        # Create a heatmap using seaborn
        ax = sns.heatmap(self.similarity_matrix,
                         xticklabels=self.malware_paths,
                         yticklabels=self.malware_paths,
                         cmap="YlGnBu",  # You can change the color map here
                         annot=False,  # Set to True to display the Jaccard index values
                         fmt=".2f")  # Format the numbers to 2 decimal places

        # Add labels and title
        ax.set_title("Malware Similarity Matrix (Jaccard Index)")
        plt.xlabel("Malware Samples")
        plt.ylabel("Malware Samples")
        plt.xticks(rotation=90, fontsize=8)
        plt.yticks(rotation=0, fontsize=8)

        # Display the heatmap
        plt.savefig(filename, format='png', bbox_inches='tight')


"""
# Si besoin de parallélisation pour les gros datasets si multicore
from joblib import Parallel, delayed

def process_pair(malware1, malware2):
    binary_vector_1 = malware_hashes[malware1]
    binary_vector_2 = malware_hashes[malware2]
    
    jaccard_index = jaccard_score(binary_vector_1, binary_vector_2)
    
    if jaccard_index > threshold:
        session.execute_write(self.neo4j.create_relationship, malware1, malware2, jaccard_index)

# Use parallel processing to speed up comparisons
Parallel(n_jobs=-1)(delayed(process_pair)(malware1, malware2) for malware1, malware2 in itertools.combinations(malware_paths, 2))

"""