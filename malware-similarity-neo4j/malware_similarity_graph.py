#!/usr/bin/python3
import argparse
import os
import itertools
from neo4j import GraphDatabase

URI = "neo4j://localhost:7687"  # Neo4j running in Docker
AUTH = ("neo4j", "password")  # Replace 'your_password' with the password you set


def jaccard(set1, set2):
    """
    Compute the Jaccard distance between two sets [0,1]
    """
    intersect = set1.intersection(set2)
    intersect_length = float(len(intersect))
    union = set1.union(set2)
    union_length = float(len(union))
    return intersect_length / union_length


def get_strings(fullpath):
    """
    Extract strings from the binary indicated by the 'fullpath'
    parameter, and then return the set of unique strings in
    the binary.
    """
    strings = os.popen("strings '{0}'".format(fullpath)).read()
    strings = set(strings.split("\n"))
    return strings


def pe_check(fullpath):
    """
    Do a cursory sanity check to make sure 'fullpath' is
    a Windows PE executable (PE executables start with the
    two bytes 'MZ')
    """
    with open(fullpath, 'rb') as file:
        return file.read(2) == b'MZ'


def create_node(tx, path):
    query = (
        "CREATE (m:Malware {path: $path}) "
        "RETURN id(m)"
    )
    tx.run(query, path=path)


def create_relationship(tx, path1, path2, weight):
    query = (
        "MATCH (a:Malware {path: $path1}), (b:Malware {path: $path2}) "
        "CREATE (a)-[:SIMILAR {weight: $weight}]->(b)"
    )
    tx.run(query, path1=path1, path2=path2, weight=weight)


def filename_from_path(path):
    return os.path.basename(path)


def main(args):
    # Do the main work : finding PE binaries in the target directory, extract features, and build the graph
    malware_paths = []  # where we'll store the malware file paths
    malware_attributes = dict()  # where we'll store the malware strings

    # TODO : donenr le nom du sample directement plutÃ´t que son chemin relatif

    for root, dirs, paths in os.walk(args.target_directory):
        for path in paths:
            fullpath = os.path.join(root, path)
            if pe_check(fullpath):
                malware_paths.append(fullpath)
                malware_attributes[fullpath] = get_strings(fullpath)

    # Connect to Neo4j
    driver = GraphDatabase.driver(URI, auth=AUTH)

    with driver.session() as session:
        # Create nodes
        for path in malware_paths:
            session.write_transaction(create_node, path)

        # Create relationships based on the Jaccard index
        for malware1, malware2 in itertools.combinations(malware_paths, 2):
            jaccard_index = jaccard(malware_attributes[malware1], malware_attributes[malware2])
            if jaccard_index > args.threshold:
                session.write_transaction(create_relationship, malware1, malware2, jaccard_index)

    driver.close()

    print("Graph exported to Neo4j database")


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="Identify similarities between malware samples based on strings and build similarity graph"
    )
    parser.add_argument(
        "target_directory",
        help="Directory containing malware"
    )
    parser.add_argument(
        "--jaccard_index_threshold", "-j", dest="threshold", type=float,
        default=0.8, help="Threshold above which to create an 'edge' between samples"
    )

    args = parser.parse_args()

    main(args)
